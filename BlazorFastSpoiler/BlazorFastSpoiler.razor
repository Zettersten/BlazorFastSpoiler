@namespace BlazorFastSpoiler.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="containerRef" 
     class="@GetCssClass()" 
     style="@GetStyle()"
     @onclick="HandleClick"
     @onkeydown="HandleKeyDown"
     role="button"
     tabindex="@(Revealed ? -1 : 0)"
     aria-label="@(Revealed ? null : "Click to reveal spoiler")"
     aria-pressed="@Revealed">
    @ChildContent
</div>

@code {
    private ElementReference containerRef;
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<BlazorFastSpoiler>? objRef;
    private bool isInitialized;
    private bool isDisposed;

    /// <summary>
    /// Child content to be displayed as spoiler text
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Scale factor for particle size (default: 1)
    /// </summary>
    [Parameter] public double Scale { get; set; } = 1.0;

    /// <summary>
    /// Minimum velocity for particles in pixels per frame (default: 0.01)
    /// </summary>
    [Parameter] public double MinVelocity { get; set; } = 0.01;

    /// <summary>
    /// Maximum velocity for particles in pixels per frame (default: 0.05)
    /// </summary>
    [Parameter] public double MaxVelocity { get; set; } = 0.05;

    /// <summary>
    /// Particle lifetime in frames at 60fps (default: 120)
    /// </summary>
    [Parameter] public int ParticleLifetime { get; set; } = 120;

    /// <summary>
    /// Target particle density (particles per 100 square pixels) (default: 8)
    /// </summary>
    [Parameter] public double Density { get; set; } = 8.0;

    /// <summary>
    /// Text fade-in duration in milliseconds when revealing (default: 300)
    /// </summary>
    [Parameter] public int RevealDuration { get; set; } = 300;

    /// <summary>
    /// Delay in milliseconds before stopping particle spawning after click (default: 0)
    /// </summary>
    [Parameter] public int SpawnStopDelay { get; set; } = 0;

    /// <summary>
    /// Enable continuous position monitoring for hover effects and CSS transforms (default: false)
    /// </summary>
    [Parameter] public bool MonitorPosition { get; set; } = false;

    /// <summary>
    /// Target frames per second for particle animation (default: 60)
    /// </summary>
    [Parameter] public int Fps { get; set; } = 60;

    /// <summary>
    /// State to track if the spoiler is currently revealing (text fading in)
    /// </summary>
    public bool Revealing { get; private set; }

    /// <summary>
    /// State to track if the spoiler has been fully revealed
    /// </summary>
    public bool Revealed { get; private set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !isDisposed)
        {
            await InitializeAsync();
        }
    }

    private async Task InitializeAsync()
    {
        if (isInitialized || isDisposed) return;

        try
        {
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorFastSpoiler/js/blazorFastSpoiler.js");

            objRef = DotNetObjectReference.Create(this);

            await jsModule.InvokeVoidAsync("initialize", 
                containerRef, 
                objRef,
                new
                {
                    scale = Scale,
                    minVelocity = MinVelocity,
                    maxVelocity = MaxVelocity,
                    particleLifetime = ParticleLifetime,
                    density = Density,
                    revealDuration = RevealDuration,
                    spawnStopDelay = SpawnStopDelay,
                    monitorPosition = MonitorPosition,
                    fps = Fps
                });

            isInitialized = true;
        }
        catch (JSException)
        {
            // Silently fail if JS interop is not available (e.g., during SSR or tests)
        }
        catch (JSDisconnectedException)
        {
            // Silently fail if JS context is disconnected
        }
    }

    private string GetCssClass() => Revealed switch
    {
        true => "blazor-fast-spoiler revealed",
        _ when Revealing => "blazor-fast-spoiler revealing",
        _ => "blazor-fast-spoiler hidden"
    };

    private string GetStyle() => Revealing 
        ? $"--reveal-duration: {RevealDuration}ms;" 
        : string.Empty;

    private async Task HandleClick()
    {
        if (Revealed || Revealing || jsModule is null) return;

        Revealing = true;
        StateHasChanged();

        await jsModule.InvokeVoidAsync("reveal");
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "Enter" or " ")
        {
            await HandleClick();
        }
    }

    [JSInvokable]
    public void OnRevealed()
    {
        Revealed = true;
        Revealing = false;
        _ = InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (isDisposed) return;
        isDisposed = true;

        if (jsModule is not null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("dispose");
                await jsModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Ignore if JS context is disconnected
            }
        }

        objRef?.Dispose();
    }
}
