@namespace BlazorFastSpoiler.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="containerRef" 
     class="@GetCssClass()" 
     style="@GetStyle()"
     @onclick="HandleClick"
     @onkeydown="HandleKeyDown"
     role="button"
     tabindex="@(Revealed ? -1 : 0)"
     aria-label="@(Revealed ? null : "Click to reveal spoiler")"
     aria-pressed="@Revealed">
    @ChildContent
</div>

@code {
    private ElementReference containerRef;
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<BlazorFastSpoiler>? objRef;
    private bool isInitialized;
    private bool isDisposed;

    /// <summary>Child content to be displayed as spoiler text</summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>Scale factor for particle size (default: 1)</summary>
    [Parameter] public double Scale { get; set; } = 1.0;

    /// <summary>Minimum velocity for particles in pixels per frame (default: 0.01)</summary>
    [Parameter] public double MinVelocity { get; set; } = 0.01;

    /// <summary>Maximum velocity for particles in pixels per frame (default: 0.05)</summary>
    [Parameter] public double MaxVelocity { get; set; } = 0.05;

    /// <summary>Particle lifetime in frames at 60fps (default: 120)</summary>
    [Parameter] public int ParticleLifetime { get; set; } = 120;

    /// <summary>Target particle density (particles per 100 square pixels) (default: 8)</summary>
    [Parameter] public double Density { get; set; } = 8.0;

    /// <summary>Text fade-in duration in milliseconds when revealing (default: 300)</summary>
    [Parameter] public int RevealDuration { get; set; } = 300;

    /// <summary>State to track if the spoiler is currently revealing (text fading in)</summary>
    public bool Revealing { get; private set; }

    /// <summary>State to track if the spoiler has been fully revealed</summary>
    public bool Revealed { get; private set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !isDisposed)
        {
            await InitializeAsync();
        }
    }

    private async Task InitializeAsync()
    {
        if (isInitialized || isDisposed) return;

        try
        {
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorFastSpoiler/js/blazorFastSpoiler.js");

            objRef = DotNetObjectReference.Create(this);

            var config = new
            {
                scale = Scale,
                minVelocity = MinVelocity,
                maxVelocity = MaxVelocity,
                particleLifetime = ParticleLifetime,
                density = Density,
                revealDuration = RevealDuration
            };

            await jsModule.InvokeVoidAsync("initialize", containerRef, config, objRef);
            isInitialized = true;
        }
        catch (JSException)
        {
            // Silently fail if JS interop is not available (e.g., during SSR)
        }
        catch (JSDisconnectedException)
        {
            // Silently fail if JS context is disconnected
        }
    }

    /// <summary>Called from JS when reveal animation starts (particles gone)</summary>
    [JSInvokable]
    public async Task OnRevealStart()
    {
        if (isDisposed) return;
        
        Revealing = true;
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>Called from JS when reveal animation completes</summary>
    [JSInvokable]
    public async Task OnRevealComplete()
    {
        if (isDisposed) return;
        
        Revealed = true;
        Revealing = false;
        await InvokeAsync(StateHasChanged);
    }

    private string GetCssClass() => Revealed switch
    {
        true => "blazor-fast-spoiler revealed",
        _ when Revealing => "blazor-fast-spoiler revealing",
        _ => "blazor-fast-spoiler hidden"
    };

    private string GetStyle() => Revealing 
        ? $"--reveal-duration: {RevealDuration}ms;" 
        : string.Empty;

    private async Task HandleClick()
    {
        if (Revealed || Revealing || isDisposed || jsModule is null) return;

        try
        {
            await jsModule.InvokeVoidAsync("reveal", containerRef);
        }
        catch (JSDisconnectedException)
        {
            // Component disposed
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "Enter" or " ")
        {
            await HandleClick();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (isDisposed) return;
        isDisposed = true;

        if (jsModule is not null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("dispose", containerRef);
                await jsModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Ignore if JS context is disconnected
            }
        }

        objRef?.Dispose();
        objRef = null;
    }
}
